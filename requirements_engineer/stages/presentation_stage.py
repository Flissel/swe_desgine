"""
Stage 5: Presentation - Iterative HTML generation with quality checks.

This stage takes all artifacts generated by previous stages and creates
a consolidated, human-readable HTML presentation. It iterates until
quality thresholds are met.

Supports two modes:
- Simple mode: Uses PresentationGenerator directly
- Multi-Agent mode: Uses PresentationOrchestrator with specialized agents
"""

from pathlib import Path
from typing import Dict, Any, List, Optional
import logging
import asyncio

from ..generators.presentation_generator import PresentationGenerator, PresentationAnalyzer

# Multi-Agent System imports
try:
    from .orchestrator import (
        PresentationOrchestrator,
        run_presentation_orchestrator,
    )
    MULTI_AGENT_AVAILABLE = True
except ImportError:
    MULTI_AGENT_AVAILABLE = False
    PresentationOrchestrator = None

# Scaffold System imports
try:
    from .orchestrator.scaffold_orchestrator import ScaffoldOrchestrator
    SCAFFOLD_AVAILABLE = True
except ImportError:
    SCAFFOLD_AVAILABLE = False
    ScaffoldOrchestrator = None

# Screen Design System imports
try:
    from .orchestrator.screen_design_orchestrator import ScreenDesignOrchestrator
    SCREEN_DESIGN_AVAILABLE = True
except ImportError:
    SCREEN_DESIGN_AVAILABLE = False
    ScreenDesignOrchestrator = None

log = logging.getLogger(__name__)


class PresentationStage:
    """Iteratively generates and improves presentation output."""

    def __init__(
        self,
        project_id: str,
        project_dir: Path,
        output_dir: Path,
        config: Dict[str, Any]
    ):
        """
        Initialize Presentation Stage.

        Args:
            project_id: Unique project identifier
            project_dir: Path to project artifacts
            output_dir: Path for presentation output
            config: Stage configuration from re_config.yaml
        """
        self.project_id = project_id
        self.project_dir = Path(project_dir)
        self.output_dir = Path(output_dir) / 'presentation'
        self.config = config

        # Get configuration values with defaults
        stages_config = config.get('stages', {})
        presentation_config = config.get('presentation', {})

        self.max_iterations = stages_config.get('stage5_max_iters', 5)
        self.quality_threshold = presentation_config.get(
            'quality_thresholds', {}
        ).get('readability', 0.8)
        self.enabled = presentation_config.get('enabled', True)
        self.max_pages = presentation_config.get('max_pages', 50)

        # Multi-Agent configuration
        multi_agent_config = presentation_config.get('multi_agent', {})
        self.use_multi_agent = (
            multi_agent_config.get('enabled', False) and MULTI_AGENT_AVAILABLE
        )

        if self.use_multi_agent:
            self.orchestrator_config = {
                **multi_agent_config.get('orchestrator', {}),
                'agents': multi_agent_config.get('agents', {}),
                'quality_targets': multi_agent_config.get('quality_targets', {}),
            }
            log.info("[Stage 5] Multi-Agent mode ENABLED")
        else:
            self.orchestrator_config = None
            if multi_agent_config.get('enabled', False) and not MULTI_AGENT_AVAILABLE:
                log.warning("[Stage 5] Multi-Agent mode requested but not available")

        # Consolidation settings
        self.consolidation = presentation_config.get('consolidation', {
            'merge_similar_requirements': True,
            'group_by_epic': True,
            'simplify_diagrams': True
        })

        # Scaffold Phase 2 configuration
        self.scaffold_config = presentation_config.get('scaffold', {})
        self.use_scaffold = (
            self.scaffold_config.get('enabled', False) and SCAFFOLD_AVAILABLE
        )
        if self.use_scaffold:
            log.info("[Stage 5] Scaffold phase ENABLED")
        elif self.scaffold_config.get('enabled', False) and not SCAFFOLD_AVAILABLE:
            log.warning("[Stage 5] Scaffold phase requested but not available")

        # Screen Design Phase 3 configuration
        self.screen_design_config = presentation_config.get('screen_design', {})
        self.use_screen_design = (
            self.screen_design_config.get('enabled', False) and SCREEN_DESIGN_AVAILABLE
        )
        if self.use_screen_design:
            log.info("[Stage 5] Screen design phase ENABLED")
        elif self.screen_design_config.get('enabled', False) and not SCREEN_DESIGN_AVAILABLE:
            log.warning("[Stage 5] Screen design phase requested but not available")

        log.info(f"[Stage 5] Initialized for {project_id}")
        log.info(f"[Stage 5] Max iterations: {self.max_iterations}")
        log.info(f"[Stage 5] Quality threshold: {self.quality_threshold}")
        log.info(f"[Stage 5] Mode: {'Multi-Agent' if self.use_multi_agent else 'Simple'}")
        log.info(f"[Stage 5] Scaffold: {'Enabled' if self.use_scaffold else 'Disabled'}")
        log.info(f"[Stage 5] Screen Design: {'Enabled' if self.use_screen_design else 'Disabled'}")

    async def run(self) -> Dict[str, Any]:
        """
        Run presentation stage with iterations.

        Returns:
            Dict with stage results including success status, iterations,
            quality score, and generated pages.
        """
        if not self.enabled:
            log.info("[Stage 5] Presentation stage is disabled")
            return {
                'success': True,
                'skipped': True,
                'reason': 'Presentation stage disabled in config'
            }

        log.info(f"[Stage 5] Starting Presentation Stage for {self.project_id}")

        # Use Multi-Agent mode if enabled
        if self.use_multi_agent:
            result = await self._run_multi_agent()
            # Phase 2: Scaffold
            if self.use_scaffold:
                scaffold_result = await self._run_scaffold_phase()
                result['scaffold'] = scaffold_result
            # Phase 3: Screen Design
            if self.use_screen_design:
                screen_result = await self._run_screen_design_phase()
                result['screen_design'] = screen_result
            return result

        # Initialize generator
        generator = PresentationGenerator(
            self.project_id,
            self.project_dir,
            self.output_dir
        )

        # Analyze artifacts
        analysis = generator.analyze_and_consolidate()
        log.info(f"[Stage 5] Analysis complete: {analysis['statistics']}")

        if analysis['consolidation_plan']:
            log.info(f"[Stage 5] Consolidation plan: {analysis['consolidation_plan']}")

        # Iterative generation
        quality_score = 0.0
        iteration = 0
        saved_files: List[Path] = []

        while quality_score < self.quality_threshold and iteration < self.max_iterations:
            iteration += 1
            log.info(f"[Stage 5] Iteration {iteration}/{self.max_iterations}")

            try:
                # Generate pages
                pages = generator.generate_pages()
                log.info(f"[Stage 5] Generated {len(pages)} pages")

                # Save to disk
                saved_files = generator.save_all()
                log.info(f"[Stage 5] Saved {len(saved_files)} files")

                # Evaluate quality
                quality_score = await self._evaluate_quality(saved_files)
                log.info(f"[Stage 5] Quality score: {quality_score:.2f}")

                if quality_score < self.quality_threshold:
                    # Get improvements and apply them
                    improvements = await self._get_improvements(
                        saved_files, quality_score
                    )
                    log.info(f"[Stage 5] Improvements needed: {improvements}")

                    # Apply improvements (if any)
                    await self._apply_improvements(generator, improvements)

            except Exception as e:
                log.error(f"[Stage 5] Error in iteration {iteration}: {e}")
                # Continue to next iteration instead of failing completely
                continue

        # Final result
        success = quality_score >= self.quality_threshold
        result = {
            'success': success,
            'iterations': iteration,
            'quality_score': quality_score,
            'pages_generated': len(generator.pages),
            'files_saved': [str(f) for f in saved_files],
            'output_dir': str(self.output_dir),
            'statistics': analysis['statistics']
        }

        if success:
            log.info(f"[Stage 5] Successfully completed after {iteration} iterations")
        else:
            log.warning(
                f"[Stage 5] Did not reach quality threshold "
                f"({quality_score:.2f} < {self.quality_threshold})"
            )

        # Phase 2: Project Scaffold Generation
        if self.use_scaffold:
            scaffold_result = await self._run_scaffold_phase()
            result['scaffold'] = scaffold_result

        # Phase 3: Screen Design
        if self.use_screen_design:
            screen_result = await self._run_screen_design_phase()
            result['screen_design'] = screen_result

        return result

    async def _evaluate_quality(self, files: List[Path]) -> float:
        """
        Evaluate quality of generated pages.

        Args:
            files: List of generated HTML file paths

        Returns:
            Quality score between 0.0 and 1.0
        """
        if not files:
            return 0.0

        total_score = 0.0
        total_checks = 0

        for file_path in files:
            if not file_path.exists():
                continue

            try:
                content = file_path.read_text(encoding='utf-8')

                # Check 1: Minimum length (content exists)
                if len(content) > 500:
                    total_score += 1
                total_checks += 1

                # Check 2: Contains sections
                if '<section' in content and '</section>' in content:
                    total_score += 1
                total_checks += 1

                # Check 3: Has navigation
                if '<nav' in content:
                    total_score += 1
                total_checks += 1

                # Check 4: Has proper structure
                if '<main>' in content and '</main>' in content:
                    total_score += 1
                total_checks += 1

                # Check 5: Has footer
                if '<footer>' in content:
                    total_score += 1
                total_checks += 1

                # Check 6: No empty sections
                if content.count('<section') == content.count('</section>'):
                    total_score += 1
                total_checks += 1

                # Check 7: Has stats or content cards
                if 'stat-card' in content or 'requirement-card' in content:
                    total_score += 1
                total_checks += 1

            except Exception as e:
                log.warning(f"Could not evaluate {file_path}: {e}")

        if total_checks == 0:
            return 0.0

        return total_score / total_checks

    async def _get_improvements(
        self,
        files: List[Path],
        current_score: float
    ) -> List[str]:
        """
        Get improvement suggestions based on current quality score.

        Args:
            files: List of generated file paths
            current_score: Current quality score

        Returns:
            List of improvement suggestions
        """
        improvements = []

        if current_score < 0.5:
            improvements.append("Add more detailed content to sections")
            improvements.append("Ensure all pages have proper HTML structure")

        if current_score < 0.7:
            improvements.append("Improve navigation structure")
            improvements.append("Add more cross-links between pages")

        if current_score < 0.8:
            improvements.append("Add visual elements (stats, cards)")
            improvements.append("Ensure consistent styling across pages")

        # Check for specific issues
        for file_path in files:
            if file_path.exists():
                content = file_path.read_text(encoding='utf-8')
                if '<section></section>' in content:
                    improvements.append(f"Remove empty sections from {file_path.name}")
                if content.count('<h2>') == 0:
                    improvements.append(f"Add section headings to {file_path.name}")

        return list(set(improvements))  # Remove duplicates

    async def _apply_improvements(
        self,
        generator: PresentationGenerator,
        improvements: List[str]
    ) -> None:
        """
        Apply improvements to the generator for the next iteration.

        This is a simplified implementation. In a production system,
        this could use an LLM to intelligently apply improvements.

        Args:
            generator: The presentation generator instance
            improvements: List of improvement suggestions
        """
        # For now, this is a placeholder that logs the improvements
        # In a full implementation, this could modify the generator's
        # behavior or use an LLM to enhance content

        for improvement in improvements:
            log.debug(f"[Stage 5] Improvement to apply: {improvement}")

        # Small delay to simulate processing
        await asyncio.sleep(0.1)

    async def _run_multi_agent(self) -> Dict[str, Any]:
        """
        Run presentation stage using the Multi-Agent Orchestrator.

        This implements the Magentic-One Two-Loop pattern with specialized agents:
        - ContentAnalyzerAgent: Analyzes artifacts from Stages 1-4
        - HTMLGeneratorAgent: Generates HTML pages
        - HTMLReviewerAgent: Evaluates quality
        - HTMLImproverAgent: Applies improvements
        - KiloIntegrationAgent: Handles complex generation tasks

        Returns:
            Dict with stage results
        """
        log.info("[Stage 5] Running Multi-Agent Orchestrator")

        # Collect artifact statistics
        artifact_stats = self._collect_artifact_stats()

        try:
            # Create and run orchestrator
            orchestrator = PresentationOrchestrator(config=self.orchestrator_config)

            result = await orchestrator.run(
                project_id=self.project_id,
                project_name=self.project_id,  # Could be enhanced to get proper name
                output_dir=str(self.output_dir.parent),  # Parent dir, orchestrator adds 'presentation'
                artifact_stats=artifact_stats
            )

            # Convert orchestrator result to stage result format
            return {
                'success': result.get('success', False),
                'iterations': result.get('iterations_completed', 0),
                'quality_score': result.get('final_quality_score', 0.0),
                'quality_achieved': result.get('quality_achieved', False),
                'pages_generated': len(result.get('generated_files', [])),
                'files_saved': result.get('generated_files', []),
                'output_dir': str(self.output_dir),
                'mode': 'multi_agent',
                'replans': result.get('replans', 0),
                'statistics': artifact_stats,
                'ledger_file': result.get('ledger_file'),
                'error': result.get('error')
            }

        except Exception as e:
            log.error(f"[Stage 5] Multi-Agent Orchestrator failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'mode': 'multi_agent',
                'fallback': 'Consider using simple mode'
            }

    async def _run_scaffold_phase(self) -> Dict[str, Any]:
        """
        Run Phase 2: Project Scaffold Generation.

        Uses the ScaffoldOrchestrator (Magentic-One Two-Loop pattern)
        to generate a real project filesystem structure from epics.

        Returns:
            Dict with scaffold generation results
        """
        log.info("[Stage 5] Starting Scaffold Phase (Phase 2)")

        artifact_stats = self._collect_artifact_stats()

        try:
            orchestrator = ScaffoldOrchestrator(config=self.scaffold_config)

            result = await orchestrator.run(
                project_id=self.project_id,
                project_name=self.project_id,
                output_dir=str(self.project_dir),
                artifact_stats=artifact_stats,
            )

            log.info(
                f"[Stage 5] Scaffold phase complete: "
                f"success={result.get('success')}, "
                f"quality={result.get('final_quality_score', 0):.1%}, "
                f"dir={result.get('scaffold_dir', '')}"
            )
            return result

        except Exception as e:
            log.error(f"[Stage 5] Scaffold phase failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'phase': 'scaffold',
            }

    async def _run_screen_design_phase(self) -> Dict[str, Any]:
        """
        Run Phase 3: Screen Design Generation.

        Uses the ScreenDesignOrchestrator (Magentic-One Two-Loop pattern)
        to generate screen designs with ASCII wireframes from user stories.

        Returns:
            Dict with screen design generation results
        """
        log.info("[Stage 5] Starting Screen Design Phase (Phase 3)")

        artifact_stats = self._collect_artifact_stats()

        try:
            orchestrator = ScreenDesignOrchestrator(config=self.screen_design_config)

            result = await orchestrator.run(
                project_id=self.project_id,
                project_name=self.project_id,
                output_dir=str(self.project_dir),
                artifact_stats=artifact_stats,
            )

            log.info(
                f"[Stage 5] Screen design phase complete: "
                f"success={result.get('success')}, "
                f"quality={result.get('final_quality_score', 0):.1%}"
            )
            return result

        except Exception as e:
            log.error(f"[Stage 5] Screen design phase failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'phase': 'screen_design',
            }

    def _collect_artifact_stats(self) -> Dict[str, int]:
        """Collect statistics about available artifacts."""
        stats = {
            'requirements': 0,
            'user_stories': 0,
            'epics': 0,
            'diagrams': 0,
            'tests': 0,
            'personas': 0,
            'screens': 0,
            'api_specs': 0,
            'tasks': 0
        }

        # Count files in project directory
        try:
            if self.project_dir.exists():
                for file in self.project_dir.rglob('*.json'):
                    name_lower = file.stem.lower()
                    if 'requirement' in name_lower:
                        stats['requirements'] += 1
                    elif 'story' in name_lower or 'user_stor' in name_lower:
                        stats['user_stories'] += 1
                    elif 'epic' in name_lower:
                        stats['epics'] += 1
                    elif 'test' in name_lower:
                        stats['tests'] += 1
                    elif 'persona' in name_lower:
                        stats['personas'] += 1
                    elif 'screen' in name_lower:
                        stats['screens'] += 1
                    elif 'api' in name_lower:
                        stats['api_specs'] += 1
                    elif 'task' in name_lower:
                        stats['tasks'] += 1

                # Count diagrams
                diagrams_dir = self.project_dir / 'diagrams'
                if diagrams_dir.exists():
                    stats['diagrams'] = len(list(diagrams_dir.glob('*.mmd')))

        except Exception as e:
            log.warning(f"[Stage 5] Error collecting artifact stats: {e}")

        log.info(f"[Stage 5] Artifact stats: {stats}")
        return stats


async def run_presentation_stage(
    project_id: str,
    project_dir: Path,
    output_dir: Path,
    config: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Convenience function to run the presentation stage.

    Args:
        project_id: Unique project identifier
        project_dir: Path to project artifacts
        output_dir: Path for output
        config: Configuration dictionary

    Returns:
        Stage results
    """
    stage = PresentationStage(project_id, project_dir, output_dir, config)
    return await stage.run()
